# OOP_L2
Шаги как делать вторую лабу по ООП

Ниже приведён план действий, который поможет вам поэтапно освоить материал и реализовать лабораторную работу. Каждый шаг включает в себя темы для изучения, примеры для экспериментов и задания для закрепления знаний.

* * *

Шаг 1. Освоение базового синтаксиса C++
---------------------------------------

**Что изучить:**

*   Структура программы на C++ (функция `main()`, директивы препроцессора `#include` и т.д.)
*   Основные типы данных (int, double, char, bool и т.п.)
*   Операторы ввода-вывода (`std::cout`, `std::cin`)
*   Основные операторы (арифметические, логические, условные конструкции, циклы)

**Что сделать:**

*   Напишите простую программу «Hello, World!»
*   Поэкспериментируйте с переменными, операторами и циклами.

* * *

[Шаг 2. Изучение определения классов, атрибутов и методов](https://github.com/Yambai/OOP_L2/blob/main/Step2.md)
--------------------------------------------------------

**Что изучить:**

*   Синтаксис определения класса:
    *   Определение атрибутов (члены данных)
    *   Определение методов (функции-члены)
*   Модификаторы доступа: `public`, `protected`, `private`
    *   Как они влияют на доступ к членам класса.

**Что сделать:**

*   Создайте небольшой класс (например, `Point` для представления точки на плоскости) с координатами.
*   Добавьте методы для установки и получения значений.
*   Добавьте вывод в методы для отладки (например, вывод в консоль при вызове метода).

_Пример:_

```cpp
#include <iostream>

class Point {
private:
    double x, y;
public:
    // Конструктор без параметров
    Point() : x(0), y(0) {
        std::cout << "Point() - конструктор без параметров\n";
    }
    
    // Конструктор с параметрами
    Point(double x_val, double y_val) : x(x_val), y(y_val) {
        std::cout << "Point(double, double) - конструктор с параметрами\n";
    }
    
    // Конструктор копирования
    Point(const Point &other) : x(other.x), y(other.y) {
        std::cout << "Point(const Point&) - конструктор копирования\n";
    }
    
    // Метод для вывода координат
    void print() const {
        std::cout << "Point(" << x << ", " << y << ")\n";
    }
    
    // Деструктор
    ~Point() {
        std::cout << "~Point() - деструктор\n";
    }
};

int main() {
    Point p1;                     // вызов конструктора без параметров
    Point p2(3.0, 4.0);           // вызов конструктора с параметрами
    Point p3 = p2;                // вызов конструктора копирования
    p1.print();
    p2.print();
    p3.print();
    return 0;
}
```

* * *

[Шаг 3. Создание объектов: статическое и динамическое выделение памяти](https://github.com/Yambai/OOP_L2/blob/main/Step3.md) 
---------------------------------------------------------------------

**Что изучить:**

*   Разница между созданием объектов на стеке и в куче.
*   Синтаксис:
    *   Статическое создание: `MyClass obj;`
    *   Динамическое создание: `MyClass* obj = new MyClass();`
*   Не забывайте про `delete` для динамических объектов!

**Что сделать:**

*   Измените предыдущую программу, добавив динамическое создание объектов.
*   Выведите в консоль отладочные сообщения, чтобы увидеть, когда вызываются конструкторы и деструкторы.

_Пример:_

```cpp
int main() {
    // Статическое создание объекта
    Point p_static(1.0, 2.0);
    
    // Динамическое создание объекта
    Point* p_dynamic = new Point(5.0, 6.0);
    
    p_static.print();
    p_dynamic->print();
    
    // Удаление динамического объекта
    delete p_dynamic;
    
    return 0;
}
```

* * *

[Шаг 4. Работа с конструкторами и деструкторами](https://github.com/Yambai/OOP_L2/blob/main/Step4.md)
----------------------------------------------

**Что изучить:**

*   Роль конструкторов и деструкторов.
*   Особенности конструктора копирования.
*   Порядок вызова конструкторов при наследовании (базовый класс создаётся перед производным, деструкторы вызываются в обратном порядке).

**Что сделать:**

*   Напишите пример с несколькими конструкторами (без параметров, с параметрами, копирующим).
*   Добавьте вывод в каждом конструкторе и деструкторе, чтобы отследить порядок вызовов.
*   Экспериментируйте с созданием объектов-наследников (см. следующий шаг).

* * *

[Шаг 5. Наследование классов](https://github.com/Yambai/OOP_L2/blob/main/Step5.md)
---------------------------

**Что изучить:**

*   Синтаксис объявления наследования:
    
    ```cpp
    class Derived : public Base { ... };
    ```
    
*   Как наследуются атрибуты и методы базового класса.
*   Порядок вызова конструкторов и деструкторов при наследовании.
*   Различия в доступности членов базового класса в зависимости от модификаторов (`public`, `protected`).

**Что сделать:**

*   Создайте базовый класс (например, `Shape`) и производный класс (например, `Circle` или `Square`).
*   В конструкторах и деструкторах выведите сообщения, чтобы увидеть порядок вызова.
*   Проверьте, что происходит при создании объекта производного класса.

_Пример:_

```cpp
#include <iostream>

class Shape {
public:
    Shape() {
        std::cout << "Shape() - базовый конструктор\n";
    }
    virtual ~Shape() {
        std::cout << "~Shape() - базовый деструктор\n";
    }
};

class Circle : public Shape {
public:
    Circle() {
        std::cout << "Circle() - производный конструктор\n";
    }
    ~Circle() {
        std::cout << "~Circle() - производный деструктор\n";
    }
};

int main() {
    Circle c;
    return 0;
}
```

* * *

Шаг 6. Виртуальные методы и полиморфизм (при необходимости)
-----------------------------------------------------------

**Что изучить:**

*   Ключевое слово `virtual` для методов.
*   Как работает позднее связывание (dynamic dispatch).
*   Разница между вызовом методов через указатель базового класса, который указывает на объект производного класса.

**Что сделать:**

*   Добавьте виртуальный метод в базовый класс (например, `draw()`).
*   Переопределите этот метод в производном классе.
*   Напишите пример, где указатель на базовый класс указывает на объект производного класса, и вызовите виртуальный метод.

_Пример:_

```cpp
class Shape {
public:
    virtual void draw() const {
        std::cout << "Drawing Shape\n";
    }
    virtual ~Shape() {}
};

class Square : public Shape {
public:
    void draw() const override {
        std::cout << "Drawing Square\n";
    }
};

int main() {
    Shape* shape = new Square();
    shape->draw();  // должен вызвать Square::draw()
    delete shape;
    return 0;
}
```

* * *

Шаг 7. Композиция объектов
--------------------------

**Что изучить:**

*   Разница между включением объекта как члена класса и использованием указателя на объект.
*   Списки инициализации для инициализации объектов-членов.
*   Когда и как вызываются конструкторы и деструкторы композитных объектов.

**Что сделать:**

*   Создайте два класса, например, `Engine` и `Car`, где объект `Engine` является членом класса `Car`.
*   Реализуйте инициализацию объекта `Engine` через список инициализации в конструкторе `Car`.
*   Затем создайте вариант, где в классе `Car` хранится указатель на `Engine`, который создаётся в конструкторе и удаляется в деструкторе.

_Пример (композиция через прямое включение):_

```cpp
class Engine {
public:
    Engine() {
        std::cout << "Engine() - конструктор\n";
    }
    ~Engine() {
        std::cout << "~Engine() - деструктор\n";
    }
};

class Car {
private:
    Engine engine;
public:
    Car() : engine() {
        std::cout << "Car() - конструктор\n";
    }
    ~Car() {
        std::cout << "~Car() - деструктор\n";
    }
};

int main() {
    Car myCar;
    return 0;
}
```

_Пример (композиция через указатель):_

```cpp
class CarWithPointer {
private:
    Engine* engine;
public:
    CarWithPointer() {
        engine = new Engine();
        std::cout << "CarWithPointer() - конструктор\n";
    }
    ~CarWithPointer() {
        delete engine;
        std::cout << "~CarWithPointer() - деструктор\n";
    }
};

int main() {
    CarWithPointer myCar;
    return 0;
}
```

* * *

Шаг 8. Анализ разницы между объектами и указателями на базовый класс
--------------------------------------------------------------------

**Что изучить:**

*   Разница между:
    *   `MyBase obj = MyDeriv();` (объект типа MyBase создаётся путём копирования части объекта MyDeriv)
    *   `MyBase* obj = new MyDeriv();` (динамическое выделение памяти, полиморфизм возможен)
*   Проблемы «object slicing» – когда при копировании объекта производного класса в объект базового класса теряются данные, специфичные для производного класса.

**Что сделать:**

*   Напишите пример, где создаётся объект производного класса, а затем происходит присваивание его базовому объекту.
*   Напишите пример, где указатель базового класса указывает на объект производного класса, и проанализируйте, какие методы доступны.

* * *

Шаг 9. Итоговое объединение знаний и создание нескольких тестовых примеров
--------------------------------------------------------------------------

**Что сделать:**

*   Напишите несколько небольших программ, каждая из которых демонстрирует отдельный аспект:
    *   Работа с конструкторами/деструкторами.
    *   Наследование и порядок вызова конструкторов/деструкторов.
    *   Использование виртуальных методов.
    *   Композиция объектов (как через прямое включение, так и через указатели).
    *   Разницу между статическим и динамическим созданием объектов.
*   В каждом классе добавьте отладочный вывод (например, в конструкторах и деструкторах), чтобы показать, в каком порядке и как происходят вызовы.

* * *

Шаг 10. Тестирование и отладка
------------------------------

**Что сделать:**

*   Запустите все написанные программы, внимательно изучите вывод в консоли.
*   Сравните порядок вызова конструкторов и деструкторов.
*   Проверьте, что происходит при уничтожении динамически созданных объектов (не забывайте использовать `delete`).
*   Экспериментируйте с наследованием: создавайте объекты базового класса, объекты производного класса, а также объекты, создаваемые через указатель базового класса, указывающий на производный объект.

* * *

Рекомендации по работе
----------------------

*   **Работайте по частям:** Не пытайтесь сразу написать всю программу. Начните с простейших примеров, а затем постепенно усложняйте код.
*   **Пишите комментарии:** Комментируйте каждую часть кода, чтобы было понятно, какой функционал она реализует.
*   **Отладочный вывод:** Обязательно добавляйте вывод в консоль во всех конструкторах и деструкторах – это ключ к пониманию, что именно происходит при создании и уничтожении объектов.
*   **Экспериментируйте с компиляцией:** Внесите небольшие изменения и наблюдайте, как меняется поведение программы.
*   **Используйте документацию и примеры:** Если что-то непонятно, обращайтесь к официальной документации C++ или учебным материалам.

* * *

Следуя этим шагам, вы постепенно освоите синтаксис C++ и все необходимые концепции, чтобы успешно выполнить лабораторную работу «Объекты и Классы». Удачи в изучении и программировании!
